/*
 * Textmagic API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.textmagic.sdk.model;

import java.util.Objects;
import java.util.Locale;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Locale;

import com.textmagic.sdk.JSON;

/**
 * SendMessageRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
public class SendMessageRequest {
  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  @javax.annotation.Nullable
  private String text;

  public static final String SERIALIZED_NAME_TEMPLATE_ID = "templateId";
  @SerializedName(SERIALIZED_NAME_TEMPLATE_ID)
  @javax.annotation.Nullable
  private Integer templateId;

  public static final String SERIALIZED_NAME_SENDING_TIME = "sendingTime";
  @SerializedName(SERIALIZED_NAME_SENDING_TIME)
  @javax.annotation.Nullable
  private Integer sendingTime;

  public static final String SERIALIZED_NAME_SENDING_DATE_TIME = "sendingDateTime";
  @SerializedName(SERIALIZED_NAME_SENDING_DATE_TIME)
  @javax.annotation.Nullable
  private String sendingDateTime;

  public static final String SERIALIZED_NAME_SENDING_TIMEZONE = "sendingTimezone";
  @SerializedName(SERIALIZED_NAME_SENDING_TIMEZONE)
  @javax.annotation.Nullable
  private String sendingTimezone;

  public static final String SERIALIZED_NAME_CONTACTS = "contacts";
  @SerializedName(SERIALIZED_NAME_CONTACTS)
  @javax.annotation.Nullable
  private String contacts;

  public static final String SERIALIZED_NAME_LISTS = "lists";
  @SerializedName(SERIALIZED_NAME_LISTS)
  @javax.annotation.Nullable
  private String lists;

  public static final String SERIALIZED_NAME_PHONES = "phones";
  @SerializedName(SERIALIZED_NAME_PHONES)
  @javax.annotation.Nullable
  private String phones;

  public static final String SERIALIZED_NAME_CUT_EXTRA = "cutExtra";
  @SerializedName(SERIALIZED_NAME_CUT_EXTRA)
  @javax.annotation.Nullable
  private Boolean cutExtra = false;

  public static final String SERIALIZED_NAME_PARTS_COUNT = "partsCount";
  @SerializedName(SERIALIZED_NAME_PARTS_COUNT)
  @javax.annotation.Nullable
  private Integer partsCount;

  public static final String SERIALIZED_NAME_REFERENCE_ID = "referenceId";
  @SerializedName(SERIALIZED_NAME_REFERENCE_ID)
  @javax.annotation.Nullable
  private Integer referenceId;

  public static final String SERIALIZED_NAME_FROM = "from";
  @SerializedName(SERIALIZED_NAME_FROM)
  @javax.annotation.Nullable
  private String from;

  public static final String SERIALIZED_NAME_RRULE = "rrule";
  @SerializedName(SERIALIZED_NAME_RRULE)
  @javax.annotation.Nullable
  private String rrule;

  public static final String SERIALIZED_NAME_CREATE_CHAT = "createChat";
  @SerializedName(SERIALIZED_NAME_CREATE_CHAT)
  @javax.annotation.Nullable
  private Boolean createChat = false;

  public static final String SERIALIZED_NAME_TTS = "tts";
  @SerializedName(SERIALIZED_NAME_TTS)
  @javax.annotation.Nullable
  private Boolean tts = false;

  public static final String SERIALIZED_NAME_LOCAL = "local";
  @SerializedName(SERIALIZED_NAME_LOCAL)
  @javax.annotation.Nullable
  private Boolean local = false;

  public static final String SERIALIZED_NAME_LOCAL_COUNTRY = "localCountry";
  @SerializedName(SERIALIZED_NAME_LOCAL_COUNTRY)
  @javax.annotation.Nullable
  private String localCountry;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  @javax.annotation.Nullable
  private String destination;

  public static final String SERIALIZED_NAME_RESOURCES = "resources";
  @SerializedName(SERIALIZED_NAME_RESOURCES)
  @javax.annotation.Nullable
  private String resources;

  public SendMessageRequest() {
  }

  public SendMessageRequest text(@javax.annotation.Nullable String text) {
    this.text = text;
    return this;
  }

  /**
   * Message text. Required if the **template_id** is not set.
   * @return text
   */
  @javax.annotation.Nullable
  public String getText() {
    return text;
  }

  public void setText(@javax.annotation.Nullable String text) {
    this.text = text;
  }


  public SendMessageRequest templateId(@javax.annotation.Nullable Integer templateId) {
    this.templateId = templateId;
    return this;
  }

  /**
   * Template used instead of message text. Required if the **text** is not set.
   * @return templateId
   */
  @javax.annotation.Nullable
  public Integer getTemplateId() {
    return templateId;
  }

  public void setTemplateId(@javax.annotation.Nullable Integer templateId) {
    this.templateId = templateId;
  }


  public SendMessageRequest sendingTime(@javax.annotation.Nullable Integer sendingTime) {
    this.sendingTime = sendingTime;
    return this;
  }

  /**
   * DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time in unix timestamp format. Default is now.
   * @return sendingTime
   */
  @javax.annotation.Nullable
  public Integer getSendingTime() {
    return sendingTime;
  }

  public void setSendingTime(@javax.annotation.Nullable Integer sendingTime) {
    this.sendingTime = sendingTime;
  }


  public SendMessageRequest sendingDateTime(@javax.annotation.Nullable String sendingDateTime) {
    this.sendingDateTime = sendingDateTime;
    return this;
  }

  /**
   * Sending time in Y-m-d H:i:s format (e.g. 2022-05-27 13:05:10). This time is relative to **sendingTimezone**. Note: for correct operation, the value of seconds must not be less than 10.
   * @return sendingDateTime
   */
  @javax.annotation.Nullable
  public String getSendingDateTime() {
    return sendingDateTime;
  }

  public void setSendingDateTime(@javax.annotation.Nullable String sendingDateTime) {
    this.sendingDateTime = sendingDateTime;
  }


  public SendMessageRequest sendingTimezone(@javax.annotation.Nullable String sendingTimezone) {
    this.sendingTimezone = sendingTimezone;
    return this;
  }

  /**
   * ID or ISO-name of timezone used for sending when sendingDateTime parameter is set. E.g. if you specify sendingDateTime &#x3D; \\\&quot;2016-05-27 13:02:33\\\&quot; and sendingTimezone &#x3D; \\\&quot;America/Buenos_Aires\\\&quot;, your message will be sent at May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is account timezone.
   * @return sendingTimezone
   */
  @javax.annotation.Nullable
  public String getSendingTimezone() {
    return sendingTimezone;
  }

  public void setSendingTimezone(@javax.annotation.Nullable String sendingTimezone) {
    this.sendingTimezone = sendingTimezone;
  }


  public SendMessageRequest contacts(@javax.annotation.Nullable String contacts) {
    this.contacts = contacts;
    return this;
  }

  /**
   * Comma separated array of contact resources id message will be sent to.
   * @return contacts
   */
  @javax.annotation.Nullable
  public String getContacts() {
    return contacts;
  }

  public void setContacts(@javax.annotation.Nullable String contacts) {
    this.contacts = contacts;
  }


  public SendMessageRequest lists(@javax.annotation.Nullable String lists) {
    this.lists = lists;
    return this;
  }

  /**
   * Comma separated array of list resources id message will be sent to.
   * @return lists
   */
  @javax.annotation.Nullable
  public String getLists() {
    return lists;
  }

  public void setLists(@javax.annotation.Nullable String lists) {
    this.lists = lists;
  }


  public SendMessageRequest phones(@javax.annotation.Nullable String phones) {
    this.phones = phones;
    return this;
  }

  /**
   * Comma separated array of E.164 phone numbers message will be sent to.
   * @return phones
   */
  @javax.annotation.Nullable
  public String getPhones() {
    return phones;
  }

  public void setPhones(@javax.annotation.Nullable String phones) {
    this.phones = phones;
  }


  public SendMessageRequest cutExtra(@javax.annotation.Nullable Boolean cutExtra) {
    this.cutExtra = cutExtra;
    return this;
  }

  /**
   * Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead.
   * @return cutExtra
   */
  @javax.annotation.Nullable
  public Boolean getCutExtra() {
    return cutExtra;
  }

  public void setCutExtra(@javax.annotation.Nullable Boolean cutExtra) {
    this.cutExtra = cutExtra;
  }


  public SendMessageRequest partsCount(@javax.annotation.Nullable Integer partsCount) {
    this.partsCount = partsCount;
    return this;
  }

  /**
   * Maximum message parts count (Textmagic allows sending 1 to 6 message parts).
   * @return partsCount
   */
  @javax.annotation.Nullable
  public Integer getPartsCount() {
    return partsCount;
  }

  public void setPartsCount(@javax.annotation.Nullable Integer partsCount) {
    this.partsCount = partsCount;
  }


  public SendMessageRequest referenceId(@javax.annotation.Nullable Integer referenceId) {
    this.referenceId = referenceId;
    return this;
  }

  /**
   * Custom message reference id which can be used in your application infrastructure.
   * @return referenceId
   */
  @javax.annotation.Nullable
  public Integer getReferenceId() {
    return referenceId;
  }

  public void setReferenceId(@javax.annotation.Nullable Integer referenceId) {
    this.referenceId = referenceId;
  }


  public SendMessageRequest from(@javax.annotation.Nullable String from) {
    this.from = from;
    return this;
  }

  /**
   * One of allowed Sender ID (phone number or alphanumeric sender ID). If specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](https://docs.textmagic.com/#tag/Sender-IDs).
   * @return from
   */
  @javax.annotation.Nullable
  public String getFrom() {
    return from;
  }

  public void setFrom(@javax.annotation.Nullable String from) {
    this.from = from;
  }


  public SendMessageRequest rrule(@javax.annotation.Nullable String rrule) {
    this.rrule = rrule;
    return this;
  }

  /**
   * iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details.
   * @return rrule
   */
  @javax.annotation.Nullable
  public String getRrule() {
    return rrule;
  }

  public void setRrule(@javax.annotation.Nullable String rrule) {
    this.rrule = rrule;
  }


  public SendMessageRequest createChat(@javax.annotation.Nullable Boolean createChat) {
    this.createChat = createChat;
    return this;
  }

  /**
   * Should sending method try to create new Chat (if not exist) with specified recipients?
   * @return createChat
   */
  @javax.annotation.Nullable
  public Boolean getCreateChat() {
    return createChat;
  }

  public void setCreateChat(@javax.annotation.Nullable Boolean createChat) {
    this.createChat = createChat;
  }


  public SendMessageRequest tts(@javax.annotation.Nullable Boolean tts) {
    this.tts = tts;
    return this;
  }

  /**
   * Send a Text-to-Speech message.
   * @return tts
   */
  @javax.annotation.Nullable
  public Boolean getTts() {
    return tts;
  }

  public void setTts(@javax.annotation.Nullable Boolean tts) {
    this.tts = tts;
  }


  public SendMessageRequest local(@javax.annotation.Nullable Boolean local) {
    this.local = local;
    return this;
  }

  /**
   * Treat phone numbers passed in the \\&#39;phones\\&#39; field as local.
   * @return local
   */
  @javax.annotation.Nullable
  public Boolean getLocal() {
    return local;
  }

  public void setLocal(@javax.annotation.Nullable Boolean local) {
    this.local = local;
  }


  public SendMessageRequest localCountry(@javax.annotation.Nullable String localCountry) {
    this.localCountry = localCountry;
    return this;
  }

  /**
   * The 2-letter ISO country code for local phone numbers, used when \\&#39;local\\&#39; is set to true. Default is the account country.
   * @return localCountry
   */
  @javax.annotation.Nullable
  public String getLocalCountry() {
    return localCountry;
  }

  public void setLocalCountry(@javax.annotation.Nullable String localCountry) {
    this.localCountry = localCountry;
  }


  public SendMessageRequest destination(@javax.annotation.Nullable String destination) {
    this.destination = destination;
    return this;
  }

  /**
   * Messsage destination type allowed [mms, tts].
   * @return destination
   */
  @javax.annotation.Nullable
  public String getDestination() {
    return destination;
  }

  public void setDestination(@javax.annotation.Nullable String destination) {
    this.destination = destination;
  }


  public SendMessageRequest resources(@javax.annotation.Nullable String resources) {
    this.resources = resources;
    return this;
  }

  /**
   * File name from mms attachment response (named as resource)
   * @return resources
   */
  @javax.annotation.Nullable
  public String getResources() {
    return resources;
  }

  public void setResources(@javax.annotation.Nullable String resources) {
    this.resources = resources;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SendMessageRequest sendMessageRequest = (SendMessageRequest) o;
    return Objects.equals(this.text, sendMessageRequest.text) &&
        Objects.equals(this.templateId, sendMessageRequest.templateId) &&
        Objects.equals(this.sendingTime, sendMessageRequest.sendingTime) &&
        Objects.equals(this.sendingDateTime, sendMessageRequest.sendingDateTime) &&
        Objects.equals(this.sendingTimezone, sendMessageRequest.sendingTimezone) &&
        Objects.equals(this.contacts, sendMessageRequest.contacts) &&
        Objects.equals(this.lists, sendMessageRequest.lists) &&
        Objects.equals(this.phones, sendMessageRequest.phones) &&
        Objects.equals(this.cutExtra, sendMessageRequest.cutExtra) &&
        Objects.equals(this.partsCount, sendMessageRequest.partsCount) &&
        Objects.equals(this.referenceId, sendMessageRequest.referenceId) &&
        Objects.equals(this.from, sendMessageRequest.from) &&
        Objects.equals(this.rrule, sendMessageRequest.rrule) &&
        Objects.equals(this.createChat, sendMessageRequest.createChat) &&
        Objects.equals(this.tts, sendMessageRequest.tts) &&
        Objects.equals(this.local, sendMessageRequest.local) &&
        Objects.equals(this.localCountry, sendMessageRequest.localCountry) &&
        Objects.equals(this.destination, sendMessageRequest.destination) &&
        Objects.equals(this.resources, sendMessageRequest.resources);
  }

  @Override
  public int hashCode() {
    return Objects.hash(text, templateId, sendingTime, sendingDateTime, sendingTimezone, contacts, lists, phones, cutExtra, partsCount, referenceId, from, rrule, createChat, tts, local, localCountry, destination, resources);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SendMessageRequest {\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    templateId: ").append(toIndentedString(templateId)).append("\n");
    sb.append("    sendingTime: ").append(toIndentedString(sendingTime)).append("\n");
    sb.append("    sendingDateTime: ").append(toIndentedString(sendingDateTime)).append("\n");
    sb.append("    sendingTimezone: ").append(toIndentedString(sendingTimezone)).append("\n");
    sb.append("    contacts: ").append(toIndentedString(contacts)).append("\n");
    sb.append("    lists: ").append(toIndentedString(lists)).append("\n");
    sb.append("    phones: ").append(toIndentedString(phones)).append("\n");
    sb.append("    cutExtra: ").append(toIndentedString(cutExtra)).append("\n");
    sb.append("    partsCount: ").append(toIndentedString(partsCount)).append("\n");
    sb.append("    referenceId: ").append(toIndentedString(referenceId)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    rrule: ").append(toIndentedString(rrule)).append("\n");
    sb.append("    createChat: ").append(toIndentedString(createChat)).append("\n");
    sb.append("    tts: ").append(toIndentedString(tts)).append("\n");
    sb.append("    local: ").append(toIndentedString(local)).append("\n");
    sb.append("    localCountry: ").append(toIndentedString(localCountry)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("text", "templateId", "sendingTime", "sendingDateTime", "sendingTimezone", "contacts", "lists", "phones", "cutExtra", "partsCount", "referenceId", "from", "rrule", "createChat", "tts", "local", "localCountry", "destination", "resources"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SendMessageRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SendMessageRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format(Locale.ROOT, "The required field(s) %s in SendMessageRequest is not found in the empty JSON string", SendMessageRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SendMessageRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format(Locale.ROOT, "The field `%s` in the JSON string is not defined in the `SendMessageRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("text") != null && !jsonObj.get("text").isJsonNull()) && !jsonObj.get("text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("text").toString()));
      }
      if ((jsonObj.get("sendingDateTime") != null && !jsonObj.get("sendingDateTime").isJsonNull()) && !jsonObj.get("sendingDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `sendingDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendingDateTime").toString()));
      }
      if ((jsonObj.get("sendingTimezone") != null && !jsonObj.get("sendingTimezone").isJsonNull()) && !jsonObj.get("sendingTimezone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `sendingTimezone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sendingTimezone").toString()));
      }
      if ((jsonObj.get("contacts") != null && !jsonObj.get("contacts").isJsonNull()) && !jsonObj.get("contacts").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `contacts` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contacts").toString()));
      }
      if ((jsonObj.get("lists") != null && !jsonObj.get("lists").isJsonNull()) && !jsonObj.get("lists").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `lists` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lists").toString()));
      }
      if ((jsonObj.get("phones") != null && !jsonObj.get("phones").isJsonNull()) && !jsonObj.get("phones").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `phones` to be a primitive type in the JSON string but got `%s`", jsonObj.get("phones").toString()));
      }
      if ((jsonObj.get("from") != null && !jsonObj.get("from").isJsonNull()) && !jsonObj.get("from").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `from` to be a primitive type in the JSON string but got `%s`", jsonObj.get("from").toString()));
      }
      if ((jsonObj.get("rrule") != null && !jsonObj.get("rrule").isJsonNull()) && !jsonObj.get("rrule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `rrule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rrule").toString()));
      }
      if ((jsonObj.get("localCountry") != null && !jsonObj.get("localCountry").isJsonNull()) && !jsonObj.get("localCountry").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `localCountry` to be a primitive type in the JSON string but got `%s`", jsonObj.get("localCountry").toString()));
      }
      if ((jsonObj.get("destination") != null && !jsonObj.get("destination").isJsonNull()) && !jsonObj.get("destination").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `destination` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destination").toString()));
      }
      if ((jsonObj.get("resources") != null && !jsonObj.get("resources").isJsonNull()) && !jsonObj.get("resources").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `resources` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resources").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SendMessageRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SendMessageRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SendMessageRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SendMessageRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<SendMessageRequest>() {
           @Override
           public void write(JsonWriter out, SendMessageRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SendMessageRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SendMessageRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SendMessageRequest
   * @throws IOException if the JSON string is invalid with respect to SendMessageRequest
   */
  public static SendMessageRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SendMessageRequest.class);
  }

  /**
   * Convert an instance of SendMessageRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

